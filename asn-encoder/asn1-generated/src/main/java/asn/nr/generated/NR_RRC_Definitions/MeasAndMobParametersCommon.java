/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 05-Aug-2021.
 */
package asn.nr.generated.NR_RRC_Definitions;

import com.objsys.asn1j.runtime.*;

public class MeasAndMobParametersCommon extends Asn1Seq {
   private static final long serialVersionUID = 55;
   static {
      _setKey (_NR_RRC_DefinitionsRtkey._rtkey);
   }

   public String getAsn1TypeName()  {
      return "MeasAndMobParametersCommon";
   }

   public Asn1BitString supportedGapPattern;  // optional
   public MeasAndMobParametersCommon_ssb_RLM ssb_RLM = null;  // optional
   public MeasAndMobParametersCommon_ssb_AndCSI_RS_RLM ssb_AndCSI_RS_RLM = null;  // optional
   public boolean mV2ExtPresent;
   public MeasAndMobParametersCommon_eventB_MeasAndReport eventB_MeasAndReport = null;  // optional
   public MeasAndMobParametersCommon_handoverFDD_TDD handoverFDD_TDD = null;  // optional
   public MeasAndMobParametersCommon_eutra_CGI_Reporting eutra_CGI_Reporting = null;  // optional
   public MeasAndMobParametersCommon_nr_CGI_Reporting nr_CGI_Reporting = null;  // optional
   public boolean mV3ExtPresent;
   public MeasAndMobParametersCommon_independentGapConfig independentGapConfig = null;  // optional
   public MeasAndMobParametersCommon_periodicEUTRA_MeasAndReport periodicEUTRA_MeasAndReport = null;  // optional
   public MeasAndMobParametersCommon_handoverFR1_FR2 handoverFR1_FR2 = null;  // optional
   public MeasAndMobParametersCommon_maxNumberCSI_RS_RRM_RS_SINR maxNumberCSI_RS_RRM_RS_SINR = null;  // optional
   public boolean mV4ExtPresent;
   public MeasAndMobParametersCommon_nr_CGI_Reporting_ENDC nr_CGI_Reporting_ENDC = null;  // optional
   public boolean mV5ExtPresent;
   public MeasAndMobParametersCommon_eutra_CGI_Reporting_NEDC eutra_CGI_Reporting_NEDC = null;  // optional
   public MeasAndMobParametersCommon_eutra_CGI_Reporting_NRDC eutra_CGI_Reporting_NRDC = null;  // optional
   public MeasAndMobParametersCommon_nr_CGI_Reporting_NEDC nr_CGI_Reporting_NEDC = null;  // optional
   public MeasAndMobParametersCommon_nr_CGI_Reporting_NRDC nr_CGI_Reporting_NRDC = null;  // optional
   public boolean mV6ExtPresent;
   public MeasAndMobParametersCommon_reportAddNeighMeasForPeriodic_r16 reportAddNeighMeasForPeriodic_r16 = null;  // optional
   public MeasAndMobParametersCommon_condHandoverParametersCommon_r16 condHandoverParametersCommon_r16;  // optional
   public MeasAndMobParametersCommon_nr_NeedForGap_Reporting_r16 nr_NeedForGap_Reporting_r16 = null;  // optional
   public Asn1BitString supportedGapPattern_NRonly_r16;  // optional
   public MeasAndMobParametersCommon_supportedGapPattern_NRonly_NEDC_r16 supportedGapPattern_NRonly_NEDC_r16 = null;  // optional
   public MeasAndMobParametersCommon_maxNumberCLI_RSSI_r16 maxNumberCLI_RSSI_r16 = null;  // optional
   public MeasAndMobParametersCommon_maxNumberCLI_SRS_RSRP_r16 maxNumberCLI_SRS_RSRP_r16 = null;  // optional
   public MeasAndMobParametersCommon_maxNumberPerSlotCLI_SRS_RSRP_r16 maxNumberPerSlotCLI_SRS_RSRP_r16 = null;  // optional
   public MeasAndMobParametersCommon_mfbi_IAB_r16 mfbi_IAB_r16 = null;  // optional
   public MeasAndMobParametersCommon_dummy dummy = null;  // optional
   public MeasAndMobParametersCommon_nr_CGI_Reporting_NPN_r16 nr_CGI_Reporting_NPN_r16 = null;  // optional
   public MeasAndMobParametersCommon_idleInactiveEUTRA_MeasReport_r16 idleInactiveEUTRA_MeasReport_r16 = null;  // optional
   public MeasAndMobParametersCommon_idleInactive_ValidityArea_r16 idleInactive_ValidityArea_r16 = null;  // optional
   public MeasAndMobParametersCommon_eutra_AutonomousGaps_r16 eutra_AutonomousGaps_r16 = null;  // optional
   public MeasAndMobParametersCommon_eutra_AutonomousGaps_NEDC_r16 eutra_AutonomousGaps_NEDC_r16 = null;  // optional
   public MeasAndMobParametersCommon_eutra_AutonomousGaps_NRDC_r16 eutra_AutonomousGaps_NRDC_r16 = null;  // optional
   public MeasAndMobParametersCommon_pcellT312_r16 pcellT312_r16 = null;  // optional
   public Asn1BitString supportedGapPattern_r16;  // optional
   public Asn1OpenExt extElem1;

   public MeasAndMobParametersCommon () {
      super();
      init();
   }

   /**
    * This constructor sets all elements to references to the 
    * given objects
    */
   public MeasAndMobParametersCommon (
      Asn1BitString supportedGapPattern_,
      MeasAndMobParametersCommon_ssb_RLM ssb_RLM_,
      MeasAndMobParametersCommon_ssb_AndCSI_RS_RLM ssb_AndCSI_RS_RLM_,
      MeasAndMobParametersCommon_eventB_MeasAndReport eventB_MeasAndReport_,
      MeasAndMobParametersCommon_handoverFDD_TDD handoverFDD_TDD_,
      MeasAndMobParametersCommon_eutra_CGI_Reporting eutra_CGI_Reporting_,
      MeasAndMobParametersCommon_nr_CGI_Reporting nr_CGI_Reporting_,
      MeasAndMobParametersCommon_independentGapConfig independentGapConfig_,
      MeasAndMobParametersCommon_periodicEUTRA_MeasAndReport periodicEUTRA_MeasAndReport_,
      MeasAndMobParametersCommon_handoverFR1_FR2 handoverFR1_FR2_,
      MeasAndMobParametersCommon_maxNumberCSI_RS_RRM_RS_SINR maxNumberCSI_RS_RRM_RS_SINR_,
      MeasAndMobParametersCommon_nr_CGI_Reporting_ENDC nr_CGI_Reporting_ENDC_,
      MeasAndMobParametersCommon_eutra_CGI_Reporting_NEDC eutra_CGI_Reporting_NEDC_,
      MeasAndMobParametersCommon_eutra_CGI_Reporting_NRDC eutra_CGI_Reporting_NRDC_,
      MeasAndMobParametersCommon_nr_CGI_Reporting_NEDC nr_CGI_Reporting_NEDC_,
      MeasAndMobParametersCommon_nr_CGI_Reporting_NRDC nr_CGI_Reporting_NRDC_,
      MeasAndMobParametersCommon_reportAddNeighMeasForPeriodic_r16 reportAddNeighMeasForPeriodic_r16_,
      MeasAndMobParametersCommon_condHandoverParametersCommon_r16 condHandoverParametersCommon_r16_,
      MeasAndMobParametersCommon_nr_NeedForGap_Reporting_r16 nr_NeedForGap_Reporting_r16_,
      Asn1BitString supportedGapPattern_NRonly_r16_,
      MeasAndMobParametersCommon_supportedGapPattern_NRonly_NEDC_r16 supportedGapPattern_NRonly_NEDC_r16_,
      MeasAndMobParametersCommon_maxNumberCLI_RSSI_r16 maxNumberCLI_RSSI_r16_,
      MeasAndMobParametersCommon_maxNumberCLI_SRS_RSRP_r16 maxNumberCLI_SRS_RSRP_r16_,
      MeasAndMobParametersCommon_maxNumberPerSlotCLI_SRS_RSRP_r16 maxNumberPerSlotCLI_SRS_RSRP_r16_,
      MeasAndMobParametersCommon_mfbi_IAB_r16 mfbi_IAB_r16_,
      MeasAndMobParametersCommon_dummy dummy_,
      MeasAndMobParametersCommon_nr_CGI_Reporting_NPN_r16 nr_CGI_Reporting_NPN_r16_,
      MeasAndMobParametersCommon_idleInactiveEUTRA_MeasReport_r16 idleInactiveEUTRA_MeasReport_r16_,
      MeasAndMobParametersCommon_idleInactive_ValidityArea_r16 idleInactive_ValidityArea_r16_,
      MeasAndMobParametersCommon_eutra_AutonomousGaps_r16 eutra_AutonomousGaps_r16_,
      MeasAndMobParametersCommon_eutra_AutonomousGaps_NEDC_r16 eutra_AutonomousGaps_NEDC_r16_,
      MeasAndMobParametersCommon_eutra_AutonomousGaps_NRDC_r16 eutra_AutonomousGaps_NRDC_r16_,
      MeasAndMobParametersCommon_pcellT312_r16 pcellT312_r16_,
      Asn1BitString supportedGapPattern_r16_
   ) {
      super();
      supportedGapPattern = supportedGapPattern_;
      ssb_RLM = ssb_RLM_;
      ssb_AndCSI_RS_RLM = ssb_AndCSI_RS_RLM_;
      eventB_MeasAndReport = eventB_MeasAndReport_;
      handoverFDD_TDD = handoverFDD_TDD_;
      eutra_CGI_Reporting = eutra_CGI_Reporting_;
      nr_CGI_Reporting = nr_CGI_Reporting_;
      independentGapConfig = independentGapConfig_;
      periodicEUTRA_MeasAndReport = periodicEUTRA_MeasAndReport_;
      handoverFR1_FR2 = handoverFR1_FR2_;
      maxNumberCSI_RS_RRM_RS_SINR = maxNumberCSI_RS_RRM_RS_SINR_;
      nr_CGI_Reporting_ENDC = nr_CGI_Reporting_ENDC_;
      eutra_CGI_Reporting_NEDC = eutra_CGI_Reporting_NEDC_;
      eutra_CGI_Reporting_NRDC = eutra_CGI_Reporting_NRDC_;
      nr_CGI_Reporting_NEDC = nr_CGI_Reporting_NEDC_;
      nr_CGI_Reporting_NRDC = nr_CGI_Reporting_NRDC_;
      reportAddNeighMeasForPeriodic_r16 = reportAddNeighMeasForPeriodic_r16_;
      condHandoverParametersCommon_r16 = condHandoverParametersCommon_r16_;
      nr_NeedForGap_Reporting_r16 = nr_NeedForGap_Reporting_r16_;
      supportedGapPattern_NRonly_r16 = supportedGapPattern_NRonly_r16_;
      supportedGapPattern_NRonly_NEDC_r16 = supportedGapPattern_NRonly_NEDC_r16_;
      maxNumberCLI_RSSI_r16 = maxNumberCLI_RSSI_r16_;
      maxNumberCLI_SRS_RSRP_r16 = maxNumberCLI_SRS_RSRP_r16_;
      maxNumberPerSlotCLI_SRS_RSRP_r16 = maxNumberPerSlotCLI_SRS_RSRP_r16_;
      mfbi_IAB_r16 = mfbi_IAB_r16_;
      dummy = dummy_;
      nr_CGI_Reporting_NPN_r16 = nr_CGI_Reporting_NPN_r16_;
      idleInactiveEUTRA_MeasReport_r16 = idleInactiveEUTRA_MeasReport_r16_;
      idleInactive_ValidityArea_r16 = idleInactive_ValidityArea_r16_;
      eutra_AutonomousGaps_r16 = eutra_AutonomousGaps_r16_;
      eutra_AutonomousGaps_NEDC_r16 = eutra_AutonomousGaps_NEDC_r16_;
      eutra_AutonomousGaps_NRDC_r16 = eutra_AutonomousGaps_NRDC_r16_;
      pcellT312_r16 = pcellT312_r16_;
      supportedGapPattern_r16 = supportedGapPattern_r16_;
   }

   public void init () {
      supportedGapPattern = null;
      ssb_RLM = null;
      ssb_AndCSI_RS_RLM = null;
      eventB_MeasAndReport = null;
      handoverFDD_TDD = null;
      eutra_CGI_Reporting = null;
      nr_CGI_Reporting = null;
      independentGapConfig = null;
      periodicEUTRA_MeasAndReport = null;
      handoverFR1_FR2 = null;
      maxNumberCSI_RS_RRM_RS_SINR = null;
      nr_CGI_Reporting_ENDC = null;
      eutra_CGI_Reporting_NEDC = null;
      eutra_CGI_Reporting_NRDC = null;
      nr_CGI_Reporting_NEDC = null;
      nr_CGI_Reporting_NRDC = null;
      reportAddNeighMeasForPeriodic_r16 = null;
      condHandoverParametersCommon_r16 = null;
      nr_NeedForGap_Reporting_r16 = null;
      supportedGapPattern_NRonly_r16 = null;
      supportedGapPattern_NRonly_NEDC_r16 = null;
      maxNumberCLI_RSSI_r16 = null;
      maxNumberCLI_SRS_RSRP_r16 = null;
      maxNumberPerSlotCLI_SRS_RSRP_r16 = null;
      mfbi_IAB_r16 = null;
      dummy = null;
      nr_CGI_Reporting_NPN_r16 = null;
      idleInactiveEUTRA_MeasReport_r16 = null;
      idleInactive_ValidityArea_r16 = null;
      eutra_AutonomousGaps_r16 = null;
      eutra_AutonomousGaps_NEDC_r16 = null;
      eutra_AutonomousGaps_NRDC_r16 = null;
      pcellT312_r16 = null;
      supportedGapPattern_r16 = null;
      extElem1 = null;
   }

   public int getElementCount() { return 35; }


   public Object getElementValue(int index){
      switch(index)  {
         case 0: return supportedGapPattern;
         case 1: return ssb_RLM;
         case 2: return ssb_AndCSI_RS_RLM;
         case 3: return eventB_MeasAndReport;
         case 4: return handoverFDD_TDD;
         case 5: return eutra_CGI_Reporting;
         case 6: return nr_CGI_Reporting;
         case 7: return independentGapConfig;
         case 8: return periodicEUTRA_MeasAndReport;
         case 9: return handoverFR1_FR2;
         case 10: return maxNumberCSI_RS_RRM_RS_SINR;
         case 11: return nr_CGI_Reporting_ENDC;
         case 12: return eutra_CGI_Reporting_NEDC;
         case 13: return eutra_CGI_Reporting_NRDC;
         case 14: return nr_CGI_Reporting_NEDC;
         case 15: return nr_CGI_Reporting_NRDC;
         case 16: return reportAddNeighMeasForPeriodic_r16;
         case 17: return condHandoverParametersCommon_r16;
         case 18: return nr_NeedForGap_Reporting_r16;
         case 19: return supportedGapPattern_NRonly_r16;
         case 20: return supportedGapPattern_NRonly_NEDC_r16;
         case 21: return maxNumberCLI_RSSI_r16;
         case 22: return maxNumberCLI_SRS_RSRP_r16;
         case 23: return maxNumberPerSlotCLI_SRS_RSRP_r16;
         case 24: return mfbi_IAB_r16;
         case 25: return dummy;
         case 26: return nr_CGI_Reporting_NPN_r16;
         case 27: return idleInactiveEUTRA_MeasReport_r16;
         case 28: return idleInactive_ValidityArea_r16;
         case 29: return eutra_AutonomousGaps_r16;
         case 30: return eutra_AutonomousGaps_NEDC_r16;
         case 31: return eutra_AutonomousGaps_NRDC_r16;
         case 32: return pcellT312_r16;
         case 33: return supportedGapPattern_r16;
         case 34: return extElem1;
         default: return null;
      }
   }


   public String getElementName(int index){
      switch(index)  {
         case 0: return "supportedGapPattern";
         case 1: return "ssb-RLM";
         case 2: return "ssb-AndCSI-RS-RLM";
         case 3: return "eventB-MeasAndReport";
         case 4: return "handoverFDD-TDD";
         case 5: return "eutra-CGI-Reporting";
         case 6: return "nr-CGI-Reporting";
         case 7: return "independentGapConfig";
         case 8: return "periodicEUTRA-MeasAndReport";
         case 9: return "handoverFR1-FR2";
         case 10: return "maxNumberCSI-RS-RRM-RS-SINR";
         case 11: return "nr-CGI-Reporting-ENDC";
         case 12: return "eutra-CGI-Reporting-NEDC";
         case 13: return "eutra-CGI-Reporting-NRDC";
         case 14: return "nr-CGI-Reporting-NEDC";
         case 15: return "nr-CGI-Reporting-NRDC";
         case 16: return "reportAddNeighMeasForPeriodic-r16";
         case 17: return "condHandoverParametersCommon-r16";
         case 18: return "nr-NeedForGap-Reporting-r16";
         case 19: return "supportedGapPattern-NRonly-r16";
         case 20: return "supportedGapPattern-NRonly-NEDC-r16";
         case 21: return "maxNumberCLI-RSSI-r16";
         case 22: return "maxNumberCLI-SRS-RSRP-r16";
         case 23: return "maxNumberPerSlotCLI-SRS-RSRP-r16";
         case 24: return "mfbi-IAB-r16";
         case 25: return "dummy";
         case 26: return "nr-CGI-Reporting-NPN-r16";
         case 27: return "idleInactiveEUTRA-MeasReport-r16";
         case 28: return "idleInactive-ValidityArea-r16";
         case 29: return "eutra-AutonomousGaps-r16";
         case 30: return "eutra-AutonomousGaps-NEDC-r16";
         case 31: return "eutra-AutonomousGaps-NRDC-r16";
         case 32: return "pcellT312-r16";
         case 33: return "supportedGapPattern-r16";
         case 34: return null;
         default: return null;
      }
   }


   public void decode (Asn1PerDecodeBuffer buffer)
      throws Asn1Exception, java.io.IOException
   {
      init ();

      // extension bit

      boolean extbit = buffer.decodeBit ("extbit");

      // optional bits

      boolean supportedGapPatternPresent = buffer.decodeBit ("supportedGapPatternPresent");
      boolean ssb_RLMPresent = buffer.decodeBit ("ssb_RLMPresent");
      boolean ssb_AndCSI_RS_RLMPresent = buffer.decodeBit ("ssb_AndCSI_RS_RLMPresent");

      // decode supportedGapPattern

      if (supportedGapPatternPresent) {
         buffer.getContext().eventDispatcher.startElement("supportedGapPattern", -1);

         supportedGapPattern = new Asn1BitString();
         supportedGapPattern.decode (buffer, 22, 22);

         buffer.invokeCharacters(supportedGapPattern.toString());
         buffer.getContext().eventDispatcher.endElement("supportedGapPattern", -1);
      }
      else {
         supportedGapPattern = null;
      }

      // decode ssb_RLM

      if (ssb_RLMPresent) {
         buffer.getContext().eventDispatcher.startElement("ssb_RLM", -1);

         int tval = MeasAndMobParametersCommon_ssb_RLM.decodeEnumValue (buffer);
         ssb_RLM = MeasAndMobParametersCommon_ssb_RLM.valueOf (tval);
         buffer.getContext().eventDispatcher.endElement("ssb_RLM", -1);
      }
      else {
         ssb_RLM = null;
      }

      // decode ssb_AndCSI_RS_RLM

      if (ssb_AndCSI_RS_RLMPresent) {
         buffer.getContext().eventDispatcher.startElement("ssb_AndCSI_RS_RLM", -1);

         int tval = MeasAndMobParametersCommon_ssb_AndCSI_RS_RLM.decodeEnumValue (buffer);
         ssb_AndCSI_RS_RLM = MeasAndMobParametersCommon_ssb_AndCSI_RS_RLM.valueOf (tval);
         buffer.getContext().eventDispatcher.endElement("ssb_AndCSI_RS_RLM", -1);
      }
      else {
         ssb_AndCSI_RS_RLM = null;
      }

      if (extbit) {

         int bitcnt = buffer.decodeSmallLength(), i = 0;
         long bitidx = buffer.getBitOffset() + bitcnt;
         boolean[] bitmap = new boolean [bitcnt];

         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("mV2ExtPresent");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("mV3ExtPresent");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("mV4ExtPresent");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("mV5ExtPresent");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("mV6ExtPresent");

         while (i < bitcnt) {
            bitmap[i++] = buffer.decodeBit ("unknown");
         }

         i = 0;

         // decode extension group

         if (i < bitcnt && bitmap[i++]) {
            mV2ExtPresent = true;
            bitidx = buffer.decodeExtLength ();

            boolean eventB_MeasAndReportPresent = buffer.decodeBit ("eventB_MeasAndReportPresent");

            boolean handoverFDD_TDDPresent = buffer.decodeBit ("handoverFDD_TDDPresent");

            boolean eutra_CGI_ReportingPresent = buffer.decodeBit ("eutra_CGI_ReportingPresent");

            boolean nr_CGI_ReportingPresent = buffer.decodeBit ("nr_CGI_ReportingPresent");

            // decode eventB_MeasAndReport

            if (eventB_MeasAndReportPresent) {
               buffer.getContext().eventDispatcher.startElement("eventB_MeasAndReport", -1);

               int tval = MeasAndMobParametersCommon_eventB_MeasAndReport.decodeEnumValue (buffer);
               eventB_MeasAndReport = MeasAndMobParametersCommon_eventB_MeasAndReport.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eventB_MeasAndReport", -1);
            }
            else {
               eventB_MeasAndReport = null;
            }

            // decode handoverFDD_TDD

            if (handoverFDD_TDDPresent) {
               buffer.getContext().eventDispatcher.startElement("handoverFDD_TDD", -1);

               int tval = MeasAndMobParametersCommon_handoverFDD_TDD.decodeEnumValue (buffer);
               handoverFDD_TDD = MeasAndMobParametersCommon_handoverFDD_TDD.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("handoverFDD_TDD", -1);
            }
            else {
               handoverFDD_TDD = null;
            }

            // decode eutra_CGI_Reporting

            if (eutra_CGI_ReportingPresent) {
               buffer.getContext().eventDispatcher.startElement("eutra_CGI_Reporting", -1);

               int tval = MeasAndMobParametersCommon_eutra_CGI_Reporting.decodeEnumValue (buffer);
               eutra_CGI_Reporting = MeasAndMobParametersCommon_eutra_CGI_Reporting.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eutra_CGI_Reporting", -1);
            }
            else {
               eutra_CGI_Reporting = null;
            }

            // decode nr_CGI_Reporting

            if (nr_CGI_ReportingPresent) {
               buffer.getContext().eventDispatcher.startElement("nr_CGI_Reporting", -1);

               int tval = MeasAndMobParametersCommon_nr_CGI_Reporting.decodeEnumValue (buffer);
               nr_CGI_Reporting = MeasAndMobParametersCommon_nr_CGI_Reporting.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("nr_CGI_Reporting", -1);
            }
            else {
               nr_CGI_Reporting = null;
            }

            buffer.moveBitCursor (bitidx);
         }

         // decode extension group

         if (i < bitcnt && bitmap[i++]) {
            mV3ExtPresent = true;
            bitidx = buffer.decodeExtLength ();

            boolean independentGapConfigPresent = buffer.decodeBit ("independentGapConfigPresent");

            boolean periodicEUTRA_MeasAndReportPresent = buffer.decodeBit ("periodicEUTRA_MeasAndReportPresent");

            boolean handoverFR1_FR2Present = buffer.decodeBit ("handoverFR1_FR2Present");

            boolean maxNumberCSI_RS_RRM_RS_SINRPresent = buffer.decodeBit ("maxNumberCSI_RS_RRM_RS_SINRPresent");

            // decode independentGapConfig

            if (independentGapConfigPresent) {
               buffer.getContext().eventDispatcher.startElement("independentGapConfig", -1);

               int tval = MeasAndMobParametersCommon_independentGapConfig.decodeEnumValue (buffer);
               independentGapConfig = MeasAndMobParametersCommon_independentGapConfig.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("independentGapConfig", -1);
            }
            else {
               independentGapConfig = null;
            }

            // decode periodicEUTRA_MeasAndReport

            if (periodicEUTRA_MeasAndReportPresent) {
               buffer.getContext().eventDispatcher.startElement("periodicEUTRA_MeasAndReport", -1);

               int tval = MeasAndMobParametersCommon_periodicEUTRA_MeasAndReport.decodeEnumValue (buffer);
               periodicEUTRA_MeasAndReport = MeasAndMobParametersCommon_periodicEUTRA_MeasAndReport.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("periodicEUTRA_MeasAndReport", -1);
            }
            else {
               periodicEUTRA_MeasAndReport = null;
            }

            // decode handoverFR1_FR2

            if (handoverFR1_FR2Present) {
               buffer.getContext().eventDispatcher.startElement("handoverFR1_FR2", -1);

               int tval = MeasAndMobParametersCommon_handoverFR1_FR2.decodeEnumValue (buffer);
               handoverFR1_FR2 = MeasAndMobParametersCommon_handoverFR1_FR2.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("handoverFR1_FR2", -1);
            }
            else {
               handoverFR1_FR2 = null;
            }

            // decode maxNumberCSI_RS_RRM_RS_SINR

            if (maxNumberCSI_RS_RRM_RS_SINRPresent) {
               buffer.getContext().eventDispatcher.startElement("maxNumberCSI_RS_RRM_RS_SINR", -1);

               int tval = MeasAndMobParametersCommon_maxNumberCSI_RS_RRM_RS_SINR.decodeEnumValue (buffer);
               maxNumberCSI_RS_RRM_RS_SINR = MeasAndMobParametersCommon_maxNumberCSI_RS_RRM_RS_SINR.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("maxNumberCSI_RS_RRM_RS_SINR", -1);
            }
            else {
               maxNumberCSI_RS_RRM_RS_SINR = null;
            }

            buffer.moveBitCursor (bitidx);
         }

         // decode extension group

         if (i < bitcnt && bitmap[i++]) {
            mV4ExtPresent = true;
            bitidx = buffer.decodeExtLength ();

            boolean nr_CGI_Reporting_ENDCPresent = buffer.decodeBit ("nr_CGI_Reporting_ENDCPresent");

            // decode nr_CGI_Reporting_ENDC

            if (nr_CGI_Reporting_ENDCPresent) {
               buffer.getContext().eventDispatcher.startElement("nr_CGI_Reporting_ENDC", -1);

               int tval = MeasAndMobParametersCommon_nr_CGI_Reporting_ENDC.decodeEnumValue (buffer);
               nr_CGI_Reporting_ENDC = MeasAndMobParametersCommon_nr_CGI_Reporting_ENDC.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("nr_CGI_Reporting_ENDC", -1);
            }
            else {
               nr_CGI_Reporting_ENDC = null;
            }

            buffer.moveBitCursor (bitidx);
         }

         // decode extension group

         if (i < bitcnt && bitmap[i++]) {
            mV5ExtPresent = true;
            bitidx = buffer.decodeExtLength ();

            boolean eutra_CGI_Reporting_NEDCPresent = buffer.decodeBit ("eutra_CGI_Reporting_NEDCPresent");

            boolean eutra_CGI_Reporting_NRDCPresent = buffer.decodeBit ("eutra_CGI_Reporting_NRDCPresent");

            boolean nr_CGI_Reporting_NEDCPresent = buffer.decodeBit ("nr_CGI_Reporting_NEDCPresent");

            boolean nr_CGI_Reporting_NRDCPresent = buffer.decodeBit ("nr_CGI_Reporting_NRDCPresent");

            // decode eutra_CGI_Reporting_NEDC

            if (eutra_CGI_Reporting_NEDCPresent) {
               buffer.getContext().eventDispatcher.startElement("eutra_CGI_Reporting_NEDC", -1);

               int tval = MeasAndMobParametersCommon_eutra_CGI_Reporting_NEDC.decodeEnumValue (buffer);
               eutra_CGI_Reporting_NEDC = MeasAndMobParametersCommon_eutra_CGI_Reporting_NEDC.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eutra_CGI_Reporting_NEDC", -1);
            }
            else {
               eutra_CGI_Reporting_NEDC = null;
            }

            // decode eutra_CGI_Reporting_NRDC

            if (eutra_CGI_Reporting_NRDCPresent) {
               buffer.getContext().eventDispatcher.startElement("eutra_CGI_Reporting_NRDC", -1);

               int tval = MeasAndMobParametersCommon_eutra_CGI_Reporting_NRDC.decodeEnumValue (buffer);
               eutra_CGI_Reporting_NRDC = MeasAndMobParametersCommon_eutra_CGI_Reporting_NRDC.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eutra_CGI_Reporting_NRDC", -1);
            }
            else {
               eutra_CGI_Reporting_NRDC = null;
            }

            // decode nr_CGI_Reporting_NEDC

            if (nr_CGI_Reporting_NEDCPresent) {
               buffer.getContext().eventDispatcher.startElement("nr_CGI_Reporting_NEDC", -1);

               int tval = MeasAndMobParametersCommon_nr_CGI_Reporting_NEDC.decodeEnumValue (buffer);
               nr_CGI_Reporting_NEDC = MeasAndMobParametersCommon_nr_CGI_Reporting_NEDC.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("nr_CGI_Reporting_NEDC", -1);
            }
            else {
               nr_CGI_Reporting_NEDC = null;
            }

            // decode nr_CGI_Reporting_NRDC

            if (nr_CGI_Reporting_NRDCPresent) {
               buffer.getContext().eventDispatcher.startElement("nr_CGI_Reporting_NRDC", -1);

               int tval = MeasAndMobParametersCommon_nr_CGI_Reporting_NRDC.decodeEnumValue (buffer);
               nr_CGI_Reporting_NRDC = MeasAndMobParametersCommon_nr_CGI_Reporting_NRDC.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("nr_CGI_Reporting_NRDC", -1);
            }
            else {
               nr_CGI_Reporting_NRDC = null;
            }

            buffer.moveBitCursor (bitidx);
         }

         // decode extension group

         if (i < bitcnt && bitmap[i++]) {
            mV6ExtPresent = true;
            bitidx = buffer.decodeExtLength ();

            boolean reportAddNeighMeasForPeriodic_r16Present = buffer.decodeBit ("reportAddNeighMeasForPeriodic_r16Present");

            boolean condHandoverParametersCommon_r16Present = buffer.decodeBit ("condHandoverParametersCommon_r16Present");

            boolean nr_NeedForGap_Reporting_r16Present = buffer.decodeBit ("nr_NeedForGap_Reporting_r16Present");

            boolean supportedGapPattern_NRonly_r16Present = buffer.decodeBit ("supportedGapPattern_NRonly_r16Present");

            boolean supportedGapPattern_NRonly_NEDC_r16Present = buffer.decodeBit ("supportedGapPattern_NRonly_NEDC_r16Present");

            boolean maxNumberCLI_RSSI_r16Present = buffer.decodeBit ("maxNumberCLI_RSSI_r16Present");

            boolean maxNumberCLI_SRS_RSRP_r16Present = buffer.decodeBit ("maxNumberCLI_SRS_RSRP_r16Present");

            boolean maxNumberPerSlotCLI_SRS_RSRP_r16Present = buffer.decodeBit ("maxNumberPerSlotCLI_SRS_RSRP_r16Present");

            boolean mfbi_IAB_r16Present = buffer.decodeBit ("mfbi_IAB_r16Present");

            boolean dummyPresent = buffer.decodeBit ("dummyPresent");

            boolean nr_CGI_Reporting_NPN_r16Present = buffer.decodeBit ("nr_CGI_Reporting_NPN_r16Present");

            boolean idleInactiveEUTRA_MeasReport_r16Present = buffer.decodeBit ("idleInactiveEUTRA_MeasReport_r16Present");

            boolean idleInactive_ValidityArea_r16Present = buffer.decodeBit ("idleInactive_ValidityArea_r16Present");

            boolean eutra_AutonomousGaps_r16Present = buffer.decodeBit ("eutra_AutonomousGaps_r16Present");

            boolean eutra_AutonomousGaps_NEDC_r16Present = buffer.decodeBit ("eutra_AutonomousGaps_NEDC_r16Present");

            boolean eutra_AutonomousGaps_NRDC_r16Present = buffer.decodeBit ("eutra_AutonomousGaps_NRDC_r16Present");

            boolean pcellT312_r16Present = buffer.decodeBit ("pcellT312_r16Present");

            boolean supportedGapPattern_r16Present = buffer.decodeBit ("supportedGapPattern_r16Present");

            // decode reportAddNeighMeasForPeriodic_r16

            if (reportAddNeighMeasForPeriodic_r16Present) {
               buffer.getContext().eventDispatcher.startElement("reportAddNeighMeasForPeriodic_r16", -1);

               int tval = MeasAndMobParametersCommon_reportAddNeighMeasForPeriodic_r16.decodeEnumValue (buffer);
               reportAddNeighMeasForPeriodic_r16 = MeasAndMobParametersCommon_reportAddNeighMeasForPeriodic_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("reportAddNeighMeasForPeriodic_r16", -1);
            }
            else {
               reportAddNeighMeasForPeriodic_r16 = null;
            }

            // decode condHandoverParametersCommon_r16

            if (condHandoverParametersCommon_r16Present) {
               buffer.getContext().eventDispatcher.startElement("condHandoverParametersCommon_r16", -1);

               condHandoverParametersCommon_r16 = new MeasAndMobParametersCommon_condHandoverParametersCommon_r16();
               condHandoverParametersCommon_r16.decode (buffer);
               buffer.getContext().eventDispatcher.endElement("condHandoverParametersCommon_r16", -1);
            }
            else {
               condHandoverParametersCommon_r16 = null;
            }

            // decode nr_NeedForGap_Reporting_r16

            if (nr_NeedForGap_Reporting_r16Present) {
               buffer.getContext().eventDispatcher.startElement("nr_NeedForGap_Reporting_r16", -1);

               int tval = MeasAndMobParametersCommon_nr_NeedForGap_Reporting_r16.decodeEnumValue (buffer);
               nr_NeedForGap_Reporting_r16 = MeasAndMobParametersCommon_nr_NeedForGap_Reporting_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("nr_NeedForGap_Reporting_r16", -1);
            }
            else {
               nr_NeedForGap_Reporting_r16 = null;
            }

            // decode supportedGapPattern_NRonly_r16

            if (supportedGapPattern_NRonly_r16Present) {
               buffer.getContext().eventDispatcher.startElement("supportedGapPattern_NRonly_r16", -1);

               supportedGapPattern_NRonly_r16 = new Asn1BitString();
               supportedGapPattern_NRonly_r16.decode (buffer, 10, 10);

               buffer.invokeCharacters(supportedGapPattern_NRonly_r16.toString());
               buffer.getContext().eventDispatcher.endElement("supportedGapPattern_NRonly_r16", -1);
            }
            else {
               supportedGapPattern_NRonly_r16 = null;
            }

            // decode supportedGapPattern_NRonly_NEDC_r16

            if (supportedGapPattern_NRonly_NEDC_r16Present) {
               buffer.getContext().eventDispatcher.startElement("supportedGapPattern_NRonly_NEDC_r16", -1);

               int tval = MeasAndMobParametersCommon_supportedGapPattern_NRonly_NEDC_r16.decodeEnumValue (buffer);
               supportedGapPattern_NRonly_NEDC_r16 = MeasAndMobParametersCommon_supportedGapPattern_NRonly_NEDC_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("supportedGapPattern_NRonly_NEDC_r16", -1);
            }
            else {
               supportedGapPattern_NRonly_NEDC_r16 = null;
            }

            // decode maxNumberCLI_RSSI_r16

            if (maxNumberCLI_RSSI_r16Present) {
               buffer.getContext().eventDispatcher.startElement("maxNumberCLI_RSSI_r16", -1);

               int tval = MeasAndMobParametersCommon_maxNumberCLI_RSSI_r16.decodeEnumValue (buffer);
               maxNumberCLI_RSSI_r16 = MeasAndMobParametersCommon_maxNumberCLI_RSSI_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("maxNumberCLI_RSSI_r16", -1);
            }
            else {
               maxNumberCLI_RSSI_r16 = null;
            }

            // decode maxNumberCLI_SRS_RSRP_r16

            if (maxNumberCLI_SRS_RSRP_r16Present) {
               buffer.getContext().eventDispatcher.startElement("maxNumberCLI_SRS_RSRP_r16", -1);

               int tval = MeasAndMobParametersCommon_maxNumberCLI_SRS_RSRP_r16.decodeEnumValue (buffer);
               maxNumberCLI_SRS_RSRP_r16 = MeasAndMobParametersCommon_maxNumberCLI_SRS_RSRP_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("maxNumberCLI_SRS_RSRP_r16", -1);
            }
            else {
               maxNumberCLI_SRS_RSRP_r16 = null;
            }

            // decode maxNumberPerSlotCLI_SRS_RSRP_r16

            if (maxNumberPerSlotCLI_SRS_RSRP_r16Present) {
               buffer.getContext().eventDispatcher.startElement("maxNumberPerSlotCLI_SRS_RSRP_r16", -1);

               int tval = MeasAndMobParametersCommon_maxNumberPerSlotCLI_SRS_RSRP_r16.decodeEnumValue (buffer);
               maxNumberPerSlotCLI_SRS_RSRP_r16 = MeasAndMobParametersCommon_maxNumberPerSlotCLI_SRS_RSRP_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("maxNumberPerSlotCLI_SRS_RSRP_r16", -1);
            }
            else {
               maxNumberPerSlotCLI_SRS_RSRP_r16 = null;
            }

            // decode mfbi_IAB_r16

            if (mfbi_IAB_r16Present) {
               buffer.getContext().eventDispatcher.startElement("mfbi_IAB_r16", -1);

               int tval = MeasAndMobParametersCommon_mfbi_IAB_r16.decodeEnumValue (buffer);
               mfbi_IAB_r16 = MeasAndMobParametersCommon_mfbi_IAB_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("mfbi_IAB_r16", -1);
            }
            else {
               mfbi_IAB_r16 = null;
            }

            // decode dummy

            if (dummyPresent) {
               buffer.getContext().eventDispatcher.startElement("dummy", -1);

               int tval = MeasAndMobParametersCommon_dummy.decodeEnumValue (buffer);
               dummy = MeasAndMobParametersCommon_dummy.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("dummy", -1);
            }
            else {
               dummy = null;
            }

            // decode nr_CGI_Reporting_NPN_r16

            if (nr_CGI_Reporting_NPN_r16Present) {
               buffer.getContext().eventDispatcher.startElement("nr_CGI_Reporting_NPN_r16", -1);

               int tval = MeasAndMobParametersCommon_nr_CGI_Reporting_NPN_r16.decodeEnumValue (buffer);
               nr_CGI_Reporting_NPN_r16 = MeasAndMobParametersCommon_nr_CGI_Reporting_NPN_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("nr_CGI_Reporting_NPN_r16", -1);
            }
            else {
               nr_CGI_Reporting_NPN_r16 = null;
            }

            // decode idleInactiveEUTRA_MeasReport_r16

            if (idleInactiveEUTRA_MeasReport_r16Present) {
               buffer.getContext().eventDispatcher.startElement("idleInactiveEUTRA_MeasReport_r16", -1);

               int tval = MeasAndMobParametersCommon_idleInactiveEUTRA_MeasReport_r16.decodeEnumValue (buffer);
               idleInactiveEUTRA_MeasReport_r16 = MeasAndMobParametersCommon_idleInactiveEUTRA_MeasReport_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("idleInactiveEUTRA_MeasReport_r16", -1);
            }
            else {
               idleInactiveEUTRA_MeasReport_r16 = null;
            }

            // decode idleInactive_ValidityArea_r16

            if (idleInactive_ValidityArea_r16Present) {
               buffer.getContext().eventDispatcher.startElement("idleInactive_ValidityArea_r16", -1);

               int tval = MeasAndMobParametersCommon_idleInactive_ValidityArea_r16.decodeEnumValue (buffer);
               idleInactive_ValidityArea_r16 = MeasAndMobParametersCommon_idleInactive_ValidityArea_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("idleInactive_ValidityArea_r16", -1);
            }
            else {
               idleInactive_ValidityArea_r16 = null;
            }

            // decode eutra_AutonomousGaps_r16

            if (eutra_AutonomousGaps_r16Present) {
               buffer.getContext().eventDispatcher.startElement("eutra_AutonomousGaps_r16", -1);

               int tval = MeasAndMobParametersCommon_eutra_AutonomousGaps_r16.decodeEnumValue (buffer);
               eutra_AutonomousGaps_r16 = MeasAndMobParametersCommon_eutra_AutonomousGaps_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eutra_AutonomousGaps_r16", -1);
            }
            else {
               eutra_AutonomousGaps_r16 = null;
            }

            // decode eutra_AutonomousGaps_NEDC_r16

            if (eutra_AutonomousGaps_NEDC_r16Present) {
               buffer.getContext().eventDispatcher.startElement("eutra_AutonomousGaps_NEDC_r16", -1);

               int tval = MeasAndMobParametersCommon_eutra_AutonomousGaps_NEDC_r16.decodeEnumValue (buffer);
               eutra_AutonomousGaps_NEDC_r16 = MeasAndMobParametersCommon_eutra_AutonomousGaps_NEDC_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eutra_AutonomousGaps_NEDC_r16", -1);
            }
            else {
               eutra_AutonomousGaps_NEDC_r16 = null;
            }

            // decode eutra_AutonomousGaps_NRDC_r16

            if (eutra_AutonomousGaps_NRDC_r16Present) {
               buffer.getContext().eventDispatcher.startElement("eutra_AutonomousGaps_NRDC_r16", -1);

               int tval = MeasAndMobParametersCommon_eutra_AutonomousGaps_NRDC_r16.decodeEnumValue (buffer);
               eutra_AutonomousGaps_NRDC_r16 = MeasAndMobParametersCommon_eutra_AutonomousGaps_NRDC_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("eutra_AutonomousGaps_NRDC_r16", -1);
            }
            else {
               eutra_AutonomousGaps_NRDC_r16 = null;
            }

            // decode pcellT312_r16

            if (pcellT312_r16Present) {
               buffer.getContext().eventDispatcher.startElement("pcellT312_r16", -1);

               int tval = MeasAndMobParametersCommon_pcellT312_r16.decodeEnumValue (buffer);
               pcellT312_r16 = MeasAndMobParametersCommon_pcellT312_r16.valueOf (tval);
               buffer.getContext().eventDispatcher.endElement("pcellT312_r16", -1);
            }
            else {
               pcellT312_r16 = null;
            }

            // decode supportedGapPattern_r16

            if (supportedGapPattern_r16Present) {
               buffer.getContext().eventDispatcher.startElement("supportedGapPattern_r16", -1);

               supportedGapPattern_r16 = new Asn1BitString();
               supportedGapPattern_r16.decode (buffer, 2, 2);

               buffer.invokeCharacters(supportedGapPattern_r16.toString());
               buffer.getContext().eventDispatcher.endElement("supportedGapPattern_r16", -1);
            }
            else {
               supportedGapPattern_r16 = null;
            }

            buffer.moveBitCursor (bitidx);
         }

         // decode unknown extension elements

         if (i < bitcnt) {
            Asn1OpenType openType = null;
            extElem1 = new Asn1OpenExt();
            int j = 0;
            while (i < bitcnt) {
               if (bitmap[i]) {
                  buffer.getContext().eventDispatcher.startElement("...", -1);

                  openType = extElem1.decodeOpenType (buffer, true, j++);

                  buffer.invokeCharacters (openType.toString());
                  buffer.getContext().eventDispatcher.endElement("...", -1);
               }
               else {
                  extElem1.setOpenType (null, j++);
               }
               i++;
            }
         }
         buffer.byteAlign ();

      }

   }

   public void encode (Asn1PerEncodeBuffer buffer)
      throws Asn1Exception, java.io.IOException
   {
      // extension bit

      boolean extbit = (mV2ExtPresent ||
      mV3ExtPresent ||
      mV4ExtPresent ||
      mV5ExtPresent ||
      mV6ExtPresent ||
      ((extElem1 != null) && (!extElem1.value.isEmpty()))
      );

      buffer.encodeBit (extbit, "extbit");

      // encode optional elements bit mask

      buffer.encodeBit ((supportedGapPattern != null), null);
      buffer.encodeBit ((ssb_RLM != null), null);
      buffer.encodeBit ((ssb_AndCSI_RS_RLM != null), null);

      // encode supportedGapPattern

      if (supportedGapPattern != null) {
         buffer.getContext().eventDispatcher.startElement("supportedGapPattern", -1);

         supportedGapPattern.encode (buffer, 22, 22);

         buffer.getContext().eventDispatcher.endElement("supportedGapPattern", -1);
      }

      // encode ssb_RLM

      if (ssb_RLM != null) {
         buffer.getContext().eventDispatcher.startElement("ssb_RLM", -1);

         ssb_RLM.encode (buffer);

         buffer.getContext().eventDispatcher.endElement("ssb_RLM", -1);
      }

      // encode ssb_AndCSI_RS_RLM

      if (ssb_AndCSI_RS_RLM != null) {
         buffer.getContext().eventDispatcher.startElement("ssb_AndCSI_RS_RLM", -1);

         ssb_AndCSI_RS_RLM.encode (buffer);

         buffer.getContext().eventDispatcher.endElement("ssb_AndCSI_RS_RLM", -1);
      }

      if (extbit) {

         // encode extension optional bits length

         int bitcnt = 5;
         if (extElem1 != null) bitcnt += extElem1.value.size();
         buffer.encodeSmallLength (bitcnt);

         // encode optional bits

         buffer.encodeBit (mV2ExtPresent, null);
         buffer.encodeBit (mV3ExtPresent, null);
         buffer.encodeBit (mV4ExtPresent, null);
         buffer.encodeBit (mV5ExtPresent, null);
         buffer.encodeBit (mV6ExtPresent, null);

         if (extElem1 != null && extElem1.value.size() > 0) {
            extElem1.encodeExtBits (buffer);
         }

         // encode extension elements

         Asn1PerEncodeBuffer mainBuffer = buffer;
         buffer = new Asn1PerEncodeBuffer (buffer.isAligned());

         if (mV2ExtPresent) {
            buffer.reset();
            buffer.encodeBit ((eventB_MeasAndReport != null), "optbit");
            buffer.encodeBit ((handoverFDD_TDD != null), "optbit");
            buffer.encodeBit ((eutra_CGI_Reporting != null), "optbit");
            buffer.encodeBit ((nr_CGI_Reporting != null), "optbit");
            if (eventB_MeasAndReport != null) {
               eventB_MeasAndReport.encode (buffer);
            }
            if (handoverFDD_TDD != null) {
               handoverFDD_TDD.encode (buffer);
            }
            if (eutra_CGI_Reporting != null) {
               eutra_CGI_Reporting.encode (buffer);
            }
            if (nr_CGI_Reporting != null) {
               nr_CGI_Reporting.encode (buffer);
            }
            mainBuffer.encodeOpenType (buffer, null);
         }

         if (mV3ExtPresent) {
            buffer.reset();
            buffer.encodeBit ((independentGapConfig != null), "optbit");
            buffer.encodeBit ((periodicEUTRA_MeasAndReport != null), "optbit");
            buffer.encodeBit ((handoverFR1_FR2 != null), "optbit");
            buffer.encodeBit ((maxNumberCSI_RS_RRM_RS_SINR != null), "optbit");
            if (independentGapConfig != null) {
               independentGapConfig.encode (buffer);
            }
            if (periodicEUTRA_MeasAndReport != null) {
               periodicEUTRA_MeasAndReport.encode (buffer);
            }
            if (handoverFR1_FR2 != null) {
               handoverFR1_FR2.encode (buffer);
            }
            if (maxNumberCSI_RS_RRM_RS_SINR != null) {
               maxNumberCSI_RS_RRM_RS_SINR.encode (buffer);
            }
            mainBuffer.encodeOpenType (buffer, null);
         }

         if (mV4ExtPresent) {
            buffer.reset();
            buffer.encodeBit ((nr_CGI_Reporting_ENDC != null), "optbit");
            if (nr_CGI_Reporting_ENDC != null) {
               nr_CGI_Reporting_ENDC.encode (buffer);
            }
            mainBuffer.encodeOpenType (buffer, null);
         }

         if (mV5ExtPresent) {
            buffer.reset();
            buffer.encodeBit ((eutra_CGI_Reporting_NEDC != null), "optbit");
            buffer.encodeBit ((eutra_CGI_Reporting_NRDC != null), "optbit");
            buffer.encodeBit ((nr_CGI_Reporting_NEDC != null), "optbit");
            buffer.encodeBit ((nr_CGI_Reporting_NRDC != null), "optbit");
            if (eutra_CGI_Reporting_NEDC != null) {
               eutra_CGI_Reporting_NEDC.encode (buffer);
            }
            if (eutra_CGI_Reporting_NRDC != null) {
               eutra_CGI_Reporting_NRDC.encode (buffer);
            }
            if (nr_CGI_Reporting_NEDC != null) {
               nr_CGI_Reporting_NEDC.encode (buffer);
            }
            if (nr_CGI_Reporting_NRDC != null) {
               nr_CGI_Reporting_NRDC.encode (buffer);
            }
            mainBuffer.encodeOpenType (buffer, null);
         }

         if (mV6ExtPresent) {
            buffer.reset();
            buffer.encodeBit ((reportAddNeighMeasForPeriodic_r16 != null), "optbit");
            buffer.encodeBit ((condHandoverParametersCommon_r16 != null), "optbit");
            buffer.encodeBit ((nr_NeedForGap_Reporting_r16 != null), "optbit");
            buffer.encodeBit ((supportedGapPattern_NRonly_r16 != null), "optbit");
            buffer.encodeBit ((supportedGapPattern_NRonly_NEDC_r16 != null), "optbit");
            buffer.encodeBit ((maxNumberCLI_RSSI_r16 != null), "optbit");
            buffer.encodeBit ((maxNumberCLI_SRS_RSRP_r16 != null), "optbit");
            buffer.encodeBit ((maxNumberPerSlotCLI_SRS_RSRP_r16 != null), "optbit");
            buffer.encodeBit ((mfbi_IAB_r16 != null), "optbit");
            buffer.encodeBit ((dummy != null), "optbit");
            buffer.encodeBit ((nr_CGI_Reporting_NPN_r16 != null), "optbit");
            buffer.encodeBit ((idleInactiveEUTRA_MeasReport_r16 != null), "optbit");
            buffer.encodeBit ((idleInactive_ValidityArea_r16 != null), "optbit");
            buffer.encodeBit ((eutra_AutonomousGaps_r16 != null), "optbit");
            buffer.encodeBit ((eutra_AutonomousGaps_NEDC_r16 != null), "optbit");
            buffer.encodeBit ((eutra_AutonomousGaps_NRDC_r16 != null), "optbit");
            buffer.encodeBit ((pcellT312_r16 != null), "optbit");
            buffer.encodeBit ((supportedGapPattern_r16 != null), "optbit");
            if (reportAddNeighMeasForPeriodic_r16 != null) {
               reportAddNeighMeasForPeriodic_r16.encode (buffer);
            }
            if (condHandoverParametersCommon_r16 != null) {
               condHandoverParametersCommon_r16.encode (buffer);
            }
            if (nr_NeedForGap_Reporting_r16 != null) {
               nr_NeedForGap_Reporting_r16.encode (buffer);
            }
            if (supportedGapPattern_NRonly_r16 != null) {
               supportedGapPattern_NRonly_r16.encode (buffer, 10, 10);
            }
            if (supportedGapPattern_NRonly_NEDC_r16 != null) {
               supportedGapPattern_NRonly_NEDC_r16.encode (buffer);
            }
            if (maxNumberCLI_RSSI_r16 != null) {
               maxNumberCLI_RSSI_r16.encode (buffer);
            }
            if (maxNumberCLI_SRS_RSRP_r16 != null) {
               maxNumberCLI_SRS_RSRP_r16.encode (buffer);
            }
            if (maxNumberPerSlotCLI_SRS_RSRP_r16 != null) {
               maxNumberPerSlotCLI_SRS_RSRP_r16.encode (buffer);
            }
            if (mfbi_IAB_r16 != null) {
               mfbi_IAB_r16.encode (buffer);
            }
            if (dummy != null) {
               dummy.encode (buffer);
            }
            if (nr_CGI_Reporting_NPN_r16 != null) {
               nr_CGI_Reporting_NPN_r16.encode (buffer);
            }
            if (idleInactiveEUTRA_MeasReport_r16 != null) {
               idleInactiveEUTRA_MeasReport_r16.encode (buffer);
            }
            if (idleInactive_ValidityArea_r16 != null) {
               idleInactive_ValidityArea_r16.encode (buffer);
            }
            if (eutra_AutonomousGaps_r16 != null) {
               eutra_AutonomousGaps_r16.encode (buffer);
            }
            if (eutra_AutonomousGaps_NEDC_r16 != null) {
               eutra_AutonomousGaps_NEDC_r16.encode (buffer);
            }
            if (eutra_AutonomousGaps_NRDC_r16 != null) {
               eutra_AutonomousGaps_NRDC_r16.encode (buffer);
            }
            if (pcellT312_r16 != null) {
               pcellT312_r16.encode (buffer);
            }
            if (supportedGapPattern_r16 != null) {
               supportedGapPattern_r16.encode (buffer, 2, 2);
            }
            mainBuffer.encodeOpenType (buffer, null);
         }

         buffer = mainBuffer;

         if (extElem1 != null && extElem1.value.size() > 0) {
            extElem1.encode (buffer);
         }
      }
   }

   public void print (java.lang.StringBuilder _sb, String _varName, int _level)
   {
      indent (_sb, _level);
      _sb.append(_varName).append(" {\n");
      if (supportedGapPattern != null) supportedGapPattern.print (_sb, "supportedGapPattern", _level+1);
      if (ssb_RLM != null) ssb_RLM.print (_sb, "ssb_RLM", _level+1);
      if (ssb_AndCSI_RS_RLM != null) ssb_AndCSI_RS_RLM.print (_sb, "ssb_AndCSI_RS_RLM", _level+1);
      if (eventB_MeasAndReport != null) eventB_MeasAndReport.print (_sb, "eventB_MeasAndReport", _level+1);
      if (handoverFDD_TDD != null) handoverFDD_TDD.print (_sb, "handoverFDD_TDD", _level+1);
      if (eutra_CGI_Reporting != null) eutra_CGI_Reporting.print (_sb, "eutra_CGI_Reporting", _level+1);
      if (nr_CGI_Reporting != null) nr_CGI_Reporting.print (_sb, "nr_CGI_Reporting", _level+1);
      if (independentGapConfig != null) independentGapConfig.print (_sb, "independentGapConfig", _level+1);
      if (periodicEUTRA_MeasAndReport != null) periodicEUTRA_MeasAndReport.print (_sb, "periodicEUTRA_MeasAndReport", _level+1);
      if (handoverFR1_FR2 != null) handoverFR1_FR2.print (_sb, "handoverFR1_FR2", _level+1);
      if (maxNumberCSI_RS_RRM_RS_SINR != null) maxNumberCSI_RS_RRM_RS_SINR.print (_sb, "maxNumberCSI_RS_RRM_RS_SINR", _level+1);
      if (nr_CGI_Reporting_ENDC != null) nr_CGI_Reporting_ENDC.print (_sb, "nr_CGI_Reporting_ENDC", _level+1);
      if (eutra_CGI_Reporting_NEDC != null) eutra_CGI_Reporting_NEDC.print (_sb, "eutra_CGI_Reporting_NEDC", _level+1);
      if (eutra_CGI_Reporting_NRDC != null) eutra_CGI_Reporting_NRDC.print (_sb, "eutra_CGI_Reporting_NRDC", _level+1);
      if (nr_CGI_Reporting_NEDC != null) nr_CGI_Reporting_NEDC.print (_sb, "nr_CGI_Reporting_NEDC", _level+1);
      if (nr_CGI_Reporting_NRDC != null) nr_CGI_Reporting_NRDC.print (_sb, "nr_CGI_Reporting_NRDC", _level+1);
      if (reportAddNeighMeasForPeriodic_r16 != null) reportAddNeighMeasForPeriodic_r16.print (_sb, "reportAddNeighMeasForPeriodic_r16", _level+1);
      if (condHandoverParametersCommon_r16 != null) condHandoverParametersCommon_r16.print (_sb, "condHandoverParametersCommon_r16", _level+1);
      if (nr_NeedForGap_Reporting_r16 != null) nr_NeedForGap_Reporting_r16.print (_sb, "nr_NeedForGap_Reporting_r16", _level+1);
      if (supportedGapPattern_NRonly_r16 != null) supportedGapPattern_NRonly_r16.print (_sb, "supportedGapPattern_NRonly_r16", _level+1);
      if (supportedGapPattern_NRonly_NEDC_r16 != null) supportedGapPattern_NRonly_NEDC_r16.print (_sb, "supportedGapPattern_NRonly_NEDC_r16", _level+1);
      if (maxNumberCLI_RSSI_r16 != null) maxNumberCLI_RSSI_r16.print (_sb, "maxNumberCLI_RSSI_r16", _level+1);
      if (maxNumberCLI_SRS_RSRP_r16 != null) maxNumberCLI_SRS_RSRP_r16.print (_sb, "maxNumberCLI_SRS_RSRP_r16", _level+1);
      if (maxNumberPerSlotCLI_SRS_RSRP_r16 != null) maxNumberPerSlotCLI_SRS_RSRP_r16.print (_sb, "maxNumberPerSlotCLI_SRS_RSRP_r16", _level+1);
      if (mfbi_IAB_r16 != null) mfbi_IAB_r16.print (_sb, "mfbi_IAB_r16", _level+1);
      if (dummy != null) dummy.print (_sb, "dummy", _level+1);
      if (nr_CGI_Reporting_NPN_r16 != null) nr_CGI_Reporting_NPN_r16.print (_sb, "nr_CGI_Reporting_NPN_r16", _level+1);
      if (idleInactiveEUTRA_MeasReport_r16 != null) idleInactiveEUTRA_MeasReport_r16.print (_sb, "idleInactiveEUTRA_MeasReport_r16", _level+1);
      if (idleInactive_ValidityArea_r16 != null) idleInactive_ValidityArea_r16.print (_sb, "idleInactive_ValidityArea_r16", _level+1);
      if (eutra_AutonomousGaps_r16 != null) eutra_AutonomousGaps_r16.print (_sb, "eutra_AutonomousGaps_r16", _level+1);
      if (eutra_AutonomousGaps_NEDC_r16 != null) eutra_AutonomousGaps_NEDC_r16.print (_sb, "eutra_AutonomousGaps_NEDC_r16", _level+1);
      if (eutra_AutonomousGaps_NRDC_r16 != null) eutra_AutonomousGaps_NRDC_r16.print (_sb, "eutra_AutonomousGaps_NRDC_r16", _level+1);
      if (pcellT312_r16 != null) pcellT312_r16.print (_sb, "pcellT312_r16", _level+1);
      if (supportedGapPattern_r16 != null) supportedGapPattern_r16.print (_sb, "supportedGapPattern_r16", _level+1);
      if (extElem1 != null) extElem1.print (_sb, "extElem1", _level+1);
      indent (_sb, _level);
      _sb.append ("}\n");
   }

}
